<?php

namespace App\Services;

use GuzzleHttp\Client;
use Illuminate\Support\Facades\Log;

class OpenAIConfig
{
    protected $apiUrl;
    protected $client;
    protected $model;

    public function __construct()
    {
        // Use only the working endpoint
        $this->apiUrl = env('LOCAL_AI_API_URL', 'http://10.58.38.218:30011/v1/completions');
        $this->model = env('LOCAL_AI_MODEL', '/mnt/data/llms/Llama-3.3-70B-Instruct');
        $this->client = new Client();
    }

    /**
     * Sends a request to Local AI API with a given prompt and review.
     *
     * @param string $prompt
     * @param string $reviewText
     * @return array|null
     */
    public function sendRequest($prompt, $reviewText)
    {
        // Combine system prompt and user content into a single prompt
        $combinedPrompt = $prompt . "\n\nReview Text: " . $reviewText;

        $requestBody = [
            'model' => $this->model,
            'prompt' => $combinedPrompt,
            'temperature' => 0.0,
            'top_p' => 0.95,
            'max_tokens' => 500,
        ];

        try {
            Log::info('Sending AI request:', [
                'url' => $this->apiUrl,
                'promptLength' => strlen($combinedPrompt)
            ]);

            $response = $this->client->post($this->apiUrl, [
                'headers' => [
                    'Content-Type' => 'application/json',
                ],
                'json' => $requestBody,
                'proxy' => [
                    'http' => null,
                    'https' => null,
                ],
                'timeout' => 300,
                'connect_timeout' => 30,
                'verify' => false,
            ]);

            $responseBody = json_decode($response->getBody()->getContents(), true);

            Log::info('AI response received:', [
                'statusCode' => $response->getStatusCode(),
                'hasChoices' => isset($responseBody['choices']),
                'hasText' => isset($responseBody['choices'][0]['text'])
            ]);

            // Extract the text from the response structure
            if (isset($responseBody['choices'][0]['text'])) {
                $rawContent = trim($responseBody['choices'][0]['text']);
                
                if (empty($rawContent)) {
                    Log::warning('AI returned empty text content');
                    return null;
                }
                
                Log::info('Raw AI content received:', [
                    'contentLength' => strlen($rawContent),
                    'contentPreview' => substr($rawContent, 0, 100) . '...'
                ]);
                
                $cleanedContent = $this->extractAndCleanJsonFromResponse($rawContent);
                
                return [
                    'choices' => [
                        [
                            'message' => [
                                'content' => $cleanedContent
                            ]
                        ]
                    ]
                ];
            } else {
                Log::warning('No choices[0].text in response:', [
                    'responseKeys' => array_keys($responseBody ?? [])
                ]);
                return null;
            }

        } catch (\Exception $e) {
            Log::error('Local AI API Request Failed: ' . $e->getMessage());
            return null;
        }
    }

    /**
     * Extract and clean JSON from the AI response
     *
     * @param string $rawResponse
     * @return string
     */
    private function extractAndCleanJsonFromResponse($rawResponse)
    {
        // Find all JSON objects in the response
        preg_match_all('/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/', $rawResponse, $matches);
        
        if (!empty($matches[0])) {
            // Get the first complete JSON object
            $jsonString = $matches[0][0];
            
            // Validate that it's proper JSON
            $decoded = json_decode($jsonString, true);
            if (json_last_error() === JSON_ERROR_NONE) {
                Log::info('Extracted valid JSON from response');
                return $jsonString;
            }
        }

        // If no valid JSON found, try to extract from lines containing JSON-like content
        $lines = explode("\n", $rawResponse);
        foreach ($lines as $line) {
            $line = trim($line);
            if (strpos($line, '{') === 0 && strpos($line, '}') !== false) {
                $decoded = json_decode($line, true);
                if (json_last_error() === JSON_ERROR_NONE) {
                    Log::info('Extracted JSON from line');
                    return $line;
                }
            }
        }

        // If still no valid JSON, return a basic response based on the text
        Log::warning('No valid JSON found, creating basic response');
        return $this->createBasicSentimentResponse($rawResponse);
    }

    /**
     * Create basic sentiment response when JSON extraction fails
     *
     * @param string $response
     * @return string
     */
    private function createBasicSentimentResponse($response)
    {
        $responseLower = strtolower($response);
        
        // Determine overall sentiment
        $overallSentiment = 'Neutral';
        if (strpos($responseLower, 'good') !== false || 
            strpos($responseLower, 'great') !== false || 
            strpos($responseLower, 'excellent') !== false ||
            strpos($responseLower, 'love') !== false) {
            $overallSentiment = 'Positive';
        } elseif (strpos($responseLower, 'bad') !== false || 
                  strpos($responseLower, 'terrible') !== false || 
                  strpos($responseLower, 'awful') !== false ||
                  strpos($responseLower, 'hate') !== false) {
            $overallSentiment = 'Negative';
        }
        
        $result = [
            'generic_attributes' => [
                'overallSentiment' => $overallSentiment,
                'customerService' => $overallSentiment,
                'userExperience' => $overallSentiment
            ],
            'category_specific_attributes' => [
                '5G network' => 'Neutral',
                'network coverage' => 'Neutral'
            ]
        ];
        
        return json_encode($result);
    }
}


==============================================
==============================================
==============================================

public function processMultipleReviews($encoder, $user, $reviews, $prompt, $appId, $source, $jopID)
{
    $openAIConfig = new OpenAIConfig();
    $processedCount = 0;
    $failedCount = 0;
    $skippedCount = 0;

    Log::info('Starting batch processing', [
        'totalReviews' => count($reviews),
        'userId' => $user->id,
        'appId' => $appId,
        'jobId' => $jopID
    ]);

    // Loop through each review
    foreach ($reviews as $index => $review) {
        try {
            // Add longer delays between requests to prevent rate limiting
            if ($index > 0) {
                Log::info('Waiting between requests to prevent rate limiting', ['waitTime' => 3]);
                sleep(3); // 3 second delay between requests
            }

            // Check if this review was already processed
            if ($source == "google" && GoogleReviewSentiment::where('review_id', $review->id)->exists()) {
                Log::info('Review already processed, skipping', ['reviewId' => $review->id]);
                $skippedCount++;
                
                // Still increment the job counter
                if ($jopID !== null) {
                    $userJob = UserJob::find($jopID);
                    if ($userJob) {
                        $userJob->increment('completed_count');
                    }
                }
                continue;
            }

            // Check for Apple reviews if source is apple
            if ($source == "apple" && AppleReviewSentiment::where('review_id', $review->id)->exists()) {
                Log::info('Review already processed, skipping', ['reviewId' => $review->id]);
                $skippedCount++;
                
                // Still increment the job counter
                if ($jopID !== null) {
                    $userJob = UserJob::find($jopID);
                    if ($userJob) {
                        $userJob->increment('completed_count');
                    }
                }
                continue;
            }

            // Refresh user data to get latest token count
            $user->refresh();

            // Token calculations
            $systemMessageTokens = count($encoder->encode($prompt));
            $userMessageTokens = count($encoder->encode($review->text));
            $inputTokens = $systemMessageTokens + $userMessageTokens;

            // Check if the user has enough tokens
            if ($user->user_token < $inputTokens) {
                Log::warning('Insufficient tokens for user', [
                    'userId' => $user->id, 
                    'reviewId' => $review->id,
                    'requiredTokens' => $inputTokens,
                    'availableTokens' => $user->user_token
                ]);
                
                // Send notification only once, not for every review
                if ($processedCount == 0 && $skippedCount == 0) {
                    $user->notify(new InsufficientTokensNotification($appId));
                }
                break; // Stop processing if insufficient tokens
            }

            Log::info('Processing review', [
                'reviewId' => $review->id,
                'reviewIndex' => $index + 1,
                'totalReviews' => count($reviews),
                'inputTokens' => $inputTokens
            ]);

            // Use the EXACT same method as your working single review
            try {
                // Send the prompt and review text to AI for analysis (exactly like single review)
                $response = $openAIConfig->sendRequest($prompt, $review->text);
        
                // Check if the response is valid (exactly like single review)
                if ($response && isset($response['choices'][0]['message']['content'])) {
                    $content = $response['choices'][0]['message']['content'];
                    
                    // Validate content is not empty
                    if (!empty(trim($content)) && $content !== '{}') {
                        // Process the content returned by AI (exactly like single review)
                        $this->processContent($content, $review->id, $inputTokens, $user, $source, $jopID);
                        $processedCount++;
                        
                        Log::info('Review processed successfully', [
                            'reviewId' => $review->id,
                            'processedCount' => $processedCount
                        ]);
                    } else {
                        Log::warning('AI returned empty content', [
                            'reviewId' => $review->id,
                            'content' => $content
                        ]);
                        $failedCount++;
                    }
                } else {
                    Log::warning('AI returned no content', ['reviewId' => $review->id]);
                    $failedCount++;
                }
            } catch (\Exception $e) {
                Log::error('Sentiment analysis processing error', ['error' => $e->getMessage(), 'reviewId' => $review->id]);
                $failedCount++;
            }

        } catch (\Exception $e) {
            Log::error('Error processing review', [
                'error' => $e->getMessage(),
                'reviewId' => $review->id,
                'trace' => $e->getTraceAsString()
            ]);
            $failedCount++;

            // If too many failures, stop processing
            if ($failedCount > 5) {
                Log::error('Too many failures, stopping batch processing', [
                    'failedCount' => $failedCount,
                    'processedCount' => $processedCount
                ]);
                break;
            }
        }
    }

    Log::info('Batch processing completed', [
        'totalReviews' => count($reviews),
        'processedCount' => $processedCount,
        'failedCount' => $failedCount,
        'skippedCount' => $skippedCount,
        'userId' => $user->id,
        'jobId' => $jopID
    ]);

    return [
        'processed' => $processedCount,
        'failed' => $failedCount,
        'skipped' => $skippedCount,
        'total' => count($reviews)
    ];
}

==============================================
==============================================
==============================================

LOCAL_AI_API_URL=http://10.58.38.218:30011/v1/completions
LOCAL_AI_MODEL=/mnt/data/llms/Llama-3.3-70B-Instruct
