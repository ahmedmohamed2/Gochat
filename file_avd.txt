ProcessSingleReviewAnalysis (New Job)

<?php

namespace App\Jobs;

use App\Http\Controllers\SentimentAssets\SentimentAssetsController;
use App\Models\User;
use App\Models\UserJob;
use App\Services\OpenAIConfig;
use App\Services\OpenAIPrompt;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Yethee\Tiktoken\EncoderProvider;

class ProcessSingleReviewAnalysis implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public $timeout = 300; // 5 minutes timeout
    public $tries = 2; // Retry once on failure

    protected $reviewId;
    protected $appId;
    protected $userId;
    protected $source;
    protected $jobId;
    protected $brandDetails;

    /**
     * Create a new job instance.
     */
    public function __construct($reviewId, $appId, $userId, $source, $jobId, $brandDetails)
    {
        $this->reviewId = $reviewId;
        $this->appId = $appId;
        $this->userId = $userId;
        $this->source = $source;
        $this->jobId = $jobId;
        $this->brandDetails = $brandDetails;
    }

    /**
     * Execute the job.
     */
    public function handle(): void
    {
        $user = User::find($this->userId);
        
        if (!$user) {
            Log::error('User not found for single review analysis', ['userId' => $this->userId]);
            return;
        }

        $assets = new SentimentAssetsController();

        // Fetch the review data
        $result = $assets->fetchReviewData($this->appId, $this->reviewId, $this->source);
        
        if (!$result) {
            Log::error('Review data not found', ['reviewId' => $this->reviewId, 'appId' => $this->appId]);
            return;
        }

        // Generate the prompt
        $openAIPrompt = new OpenAIPrompt();
        $prompt = $openAIPrompt->sentimentAnalysisPrompt($this->brandDetails);

        // Calculate tokens
        $encoder = (new EncoderProvider())->getForModel('gpt-4o');
        $inputTokens = $assets->calculateTokens($prompt, $result->text);

        // Refresh user data
        $user->refresh();

        // Check if the user has sufficient tokens
        if ($user->user_token < $inputTokens) {
            Log::info('Insufficient tokens for single review', [
                'userId' => $user->id,
                'reviewId' => $this->reviewId,
                'requiredTokens' => $inputTokens,
                'availableTokens' => $user->user_token
            ]);
            return;
        }

        // Check if already processed
        if ($this->source == "google" && \App\Models\GoogleReviewSentiment::where('review_id', $this->reviewId)->exists()) {
            Log::info('Review already processed', ['reviewId' => $this->reviewId]);
            $this->incrementJobCounter();
            return;
        }

        if ($this->source == "apple" && \App\Models\AppleReviewSentiment::where('review_id', $this->reviewId)->exists()) {
            Log::info('Review already processed', ['reviewId' => $this->reviewId]);
            $this->incrementJobCounter();
            return;
        }

        // Initialize AI Config and send request (same as working single review)
        $openAIConfig = new OpenAIConfig();
        
        try {
            Log::info('Processing single review', ['reviewId' => $this->reviewId]);
            
            // Send the prompt and review text to AI for analysis (exactly like working single review)
            $response = $openAIConfig->sendRequest($prompt, $result->text);

            // Check if the response is valid (exactly like working single review)
            if ($response && isset($response['choices'][0]['message']['content'])) {
                // Process the content returned by AI (exactly like working single review)
                $assets->processContent(
                    $response['choices'][0]['message']['content'], 
                    $this->reviewId, 
                    $inputTokens, 
                    $user, 
                    $this->source,
                    $this->jobId
                );

                Log::info('Single review analysis completed successfully', ['reviewId' => $this->reviewId]);
            } else {
                Log::warning('AI returned no content for single review', ['reviewId' => $this->reviewId]);
                throw new \Exception('AI returned no valid content');
            }

        } catch (\Exception $e) {
            Log::error('Single review analysis failed', [
                'reviewId' => $this->reviewId,
                'error' => $e->getMessage()
            ]);
            
            // Re-throw to trigger retry mechanism
            throw $e;
        }
    }

    /**
     * Increment job counter
     */
    private function incrementJobCounter()
    {
        if ($this->jobId !== null) {
            try {
                $userJob = \App\Models\UserJob::find($this->jobId);
                if ($userJob) {
                    $userJob->increment('completed_count');
                    Log::info('Job counter incremented for skipped review', [
                        'jobId' => $this->jobId,
                        'reviewId' => $this->reviewId
                    ]);
                }
            } catch (\Exception $e) {
                Log::error('Failed to increment job counter', [
                    'jobId' => $this->jobId,
                    'error' => $e->getMessage()
                ]);
            }
        }
    }

    /**
     * Handle a job failure.
     */
    public function failed(\Throwable $exception)
    {
        Log::error('Single review analysis permanently failed', [
            'reviewId' => $this->reviewId,
            'userId' => $this->userId,
            'error' => $exception->getMessage()
        ]);
    }
}

########################################
########################################
########################################

<?php

namespace App\Jobs;

use App\Events\NewSentimentEvent;
use App\Http\Controllers\SentimentAssets\SentimentAssetsController;
use App\Models\GoogleApp;
use App\Models\User;
use App\Models\UserJob;
use App\Notifications\GoogleSentiment;
use App\Services\OpenAIPrompt;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class ProcessGooglePlayAnalysis implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public $timeout = 1800; // 30 minutes timeout
    protected $requestData;
    protected $userId;
    
    /**
     * Create a new job instance.
     */
    public function __construct($requestData, $userId)
    {
        $this->requestData = $requestData;
        $this->userId = $userId;
    }

    /**
     * Execute the job.
     */
    public function handle(): void
    {
        $validatedData = $this->requestData;
        $user = User::find($this->userId);
        $job = null;

        try {
            if (!$user) {
                Log::error('User not found', ['userId' => $this->userId]);
                return;
            }

            // Save job details in `user_jobs`
            $job = new UserJob([
                'job_id'        => $this->job->getJobId(),
                'status'        => 'processing',
                'request_type'  => 'sentiment',
                'request_count' => $validatedData['number_of_reviews'],
                'completed_count' => 0,
                'user_id' => $user->id
            ]);

            $googleApp = GoogleApp::find($validatedData['appId']);
            if (!$googleApp) {
                Log::error('Google app not found', ['appId' => $validatedData['appId']]);
                return;
            }
            
            $googleApp->jobs()->save($job);
            $jobId = $job->id;

            $assets = new SentimentAssetsController();

            $reviews = $assets->fetchReviews($validatedData['appId'], $validatedData['number_of_reviews'], "google");
            
            if (empty($reviews)) {
                Log::warning('No reviews found to process', ['appId' => $validatedData['appId']]);
                $job->update(['status' => 'completed']);
                return;
            }

            $brandDetails = $assets->getBrandDetails($validatedData['appId'], "google");

            if (empty($brandDetails)) {
                Log::error('App details not found', ['appId' => $validatedData['appId']]);
                $job->update(['status' => 'failed']);
                return;
            }

            Log::info('Starting individual review job dispatch', [
                'totalReviews' => count($reviews),
                'appId' => $validatedData['appId'],
                'jobId' => $jobId
            ]);

            // Dispatch individual jobs for each review with delays
            $delay = 0;
            foreach ($reviews as $index => $review) {
                // Dispatch each review as a separate job with increasing delay
                ProcessSingleReviewAnalysis::dispatch(
                    $review->id,
                    $validatedData['appId'],
                    $user->id,
                    'google',
                    $jobId,
                    $brandDetails
                )->delay(now()->addSeconds($delay));

                // Increase delay by 5 seconds for each subsequent job
                $delay += 5;

                Log::info('Dispatched single review job', [
                    'reviewId' => $review->id,
                    'delay' => $delay - 5,
                    'jobIndex' => $index + 1
                ]);
            }

            // Update job status to processing (individual jobs will update completed_count)
            $job->update(['status' => 'processing']);

            Log::info('All individual review jobs dispatched', [
                'totalJobs' => count($reviews),
                'appId' => $validatedData['appId'],
                'jobId' => $jobId,
                'totalDelay' => $delay
            ]);

            // Schedule a job to check completion and send notification
            CheckBatchCompletion::dispatch($jobId, $user->id, $brandDetails)
                ->delay(now()->addSeconds($delay + 60)); // Check 1 minute after last job

        } catch (\Exception $e) {
            Log::error("Batch job dispatch failed: {$e->getMessage()}", [
                'userId' => $this->userId,
                'appId' => $validatedData['appId'] ?? null,
                'exception' => $e,
            ]);

            if ($job) {
                $job->update(['status' => 'failed']);
            }

            throw $e;
        }
    }
}


########################################
########################################
########################################

CheckBatchCompletion (New Job)

<?php

namespace App\Jobs;

use App\Events\NewSentimentEvent;
use App\Models\User;
use App\Models\UserJob;
use App\Notifications\GoogleSentiment;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class CheckBatchCompletion implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public $timeout = 60;
    
    protected $jobId;
    protected $userId;
    protected $brandDetails;

    /**
     * Create a new job instance.
     */
    public function __construct($jobId, $userId, $brandDetails)
    {
        $this->jobId = $jobId;
        $this->userId = $userId;
        $this->brandDetails = $brandDetails;
    }

    /**
     * Execute the job.
     */
    public function handle(): void
    {
        try {
            $job = UserJob::find($this->jobId);
            $user = User::find($this->userId);

            if (!$job || !$user) {
                Log::error('Job or user not found for completion check', [
                    'jobId' => $this->jobId,
                    'userId' => $this->userId
                ]);
                return;
            }

            Log::info('Checking batch completion', [
                'jobId' => $this->jobId,
                'completedCount' => $job->completed_count,
                'requestCount' => $job->request_count
            ]);

            // Check if all reviews have been processed
            if ($job->completed_count >= $job->request_count) {
                // Mark job as completed
                $job->update(['status' => 'completed']);

                Log::info('Batch processing completed', [
                    'jobId' => $this->jobId,
                    'completedCount' => $job->completed_count,
                    'requestCount' => $job->request_count
                ]);

                // Send notification if user still has tokens
                if ($user->user_token > 0) {
                    try {
                        $user->notify(new GoogleSentiment(
                            $this->brandDetails['brandName'], 
                            $this->brandDetails['brandId']
                        ));
                        Log::info('Completion notification sent', ['userId' => $user->id]);
                    } catch (\Exception $e) {
                        Log::error('Failed to send completion notification', [
                            'userId' => $user->id,
                            'error' => $e->getMessage()
                        ]);
                    }
                }

                // Broadcast completion event
                try {
                    broadcast(new NewSentimentEvent());
                } catch (\Exception $e) {
                    Log::error('Failed to broadcast completion event', [
                        'error' => $e->getMessage()
                    ]);
                }

            } else {
                // Not all jobs completed yet, schedule another check
                Log::info('Batch not yet complete, scheduling another check', [
                    'jobId' => $this->jobId,
                    'completedCount' => $job->completed_count,
                    'requestCount' => $job->request_count
                ]);

                CheckBatchCompletion::dispatch($this->jobId, $this->userId, $this->brandDetails)
                    ->delay(now()->addMinutes(2)); // Check again in 2 minutes
            }

        } catch (\Exception $e) {
            Log::error('Batch completion check failed', [
                'jobId' => $this->jobId,
                'error' => $e->getMessage()
            ]);
        }
    }
}



