<?php

namespace App\Services;

use GuzzleHttp\Client;
use Illuminate\Support\Facades\Log;

class OpenAIConfig
{
    protected $apiUrl;
    protected $client;
    protected $model;

    public function __construct()
    {
        // Try different possible endpoints
        $this->apiUrl = env('LOCAL_AI_API_URL', 'http://10.58.38.218:30011/v1/chat/completions');
        $this->model = env('LOCAL_AI_MODEL', '/mnt/data/llms/Llama-3.3-70B-Instruct');
        $this->client = new Client();
    }

    /**
     * Sends a request to Local AI API with a given prompt and review.
     *
     * @param string $prompt
     * @param string $reviewText
     * @return array|null
     */
    public function sendRequest($prompt, $reviewText)
    {
        // Try different request formats
        $endpoints = [
            // Format 1: Chat completions format
            [
                'url' => 'http://10.58.38.218:30011/v1/chat/completions',
                'body' => [
                    'model' => $this->model,
                    'messages' => [
                        ['role' => 'system', 'content' => $prompt],
                        ['role' => 'user', 'content' => $reviewText]
                    ],
                    'temperature' => 0.0,
                    'max_tokens' => 500,
                ]
            ],
            // Format 2: Original completions format
            [
                'url' => 'http://10.58.38.218:30011/v1/completions',
                'body' => [
                    'model' => $this->model,
                    'prompt' => $prompt . "\n\nReview Text: " . $reviewText,
                    'temperature' => 0.0,
                    'top_p' => 0.95,
                    'max_tokens' => 500,
                ]
            ],
            // Format 3: Without /v1
            [
                'url' => 'http://10.58.38.218:30011/completions',
                'body' => [
                    'model' => $this->model,
                    'prompt' => $prompt . "\n\nReview Text: " . $reviewText,
                    'temperature' => 0.0,
                    'max_tokens' => 500,
                ]
            ],
            // Format 4: Generate endpoint
            [
                'url' => 'http://10.58.38.218:30011/generate',
                'body' => [
                    'model' => $this->model,
                    'prompt' => $prompt . "\n\nReview Text: " . $reviewText,
                    'temperature' => 0.0,
                    'max_tokens' => 500,
                ]
            ]
        ];

        foreach ($endpoints as $index => $endpoint) {
            Log::info("Trying endpoint {$index}", ['url' => $endpoint['url']]);
            
            $result = $this->makeRequest($endpoint['url'], $endpoint['body']);
            if ($result) {
                Log::info("Endpoint {$index} worked!", ['url' => $endpoint['url']]);
                return $result;
            }
        }

        Log::error('All endpoints failed');
        return null;
    }

    /**
     * Make the actual request
     */
    private function makeRequest($url, $requestBody)
    {

        try {
            Log::info('Sending AI request:', [
                'url' => $this->apiUrl,
                'requestBody' => $requestBody
            ]);

            $response = $this->client->post($this->apiUrl, [
                'headers' => [
                    'Content-Type' => 'application/json',
                ],
                'json' => $requestBody,
                'proxy' => [
                    'http' => null,
                    'https' => null,
                ],
                'timeout' => 300,
                'connect_timeout' => 30,
                'verify' => false,
            ]);

            $responseBody = json_decode($response->getBody()->getContents(), true);

            Log::info('AI response received:', [
                'statusCode' => $response->getStatusCode(),
                'responseBody' => $responseBody
            ]);

            // Extract the text from the response structure
            if (isset($responseBody['choices'][0]['text'])) {
                $rawContent = trim($responseBody['choices'][0]['text']);
                
                Log::info('Raw AI content:', [
                    'rawContent' => $rawContent,
                    'contentLength' => strlen($rawContent)
                ]);
                
                $cleanedContent = $this->extractAndCleanJsonFromResponse($rawContent);
                
                Log::info('Cleaned AI content:', [
                    'cleanedContent' => $cleanedContent
                ]);
                
                return [
                    'choices' => [
                        [
                            'message' => [
                                'content' => $cleanedContent
                            ]
                        ]
                    ]
                ];
            } else {
                Log::warning('No choices[0].text in response:', [
                    'responseBody' => $responseBody
                ]);
            }

            return $responseBody;
        } catch (\Exception $e) {
            Log::error('Local AI API Request Failed: ' . $e->getMessage(), [
                'url' => $this->apiUrl,
                'requestBody' => $requestBody
            ]);
            return null;
        }
    }

    /**
     * Extract and clean JSON from the AI response
     *
     * @param string $rawResponse
     * @return string
     */
    private function extractAndCleanJsonFromResponse($rawResponse)
    {
        // Log the raw response for debugging
        Log::info('Raw AI Response:', ['response' => $rawResponse]);

        // Check if the response contains descriptive text instead of JSON
        if (strpos($rawResponse, '{') === false || strpos($rawResponse, '}') === false) {
            Log::warning('Response contains no JSON structure, attempting to parse descriptive text');
            return $this->parseDescriptiveResponse($rawResponse);
        }

        // Find all JSON objects in the response
        preg_match_all('/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/', $rawResponse, $matches);
        
        if (!empty($matches[0])) {
            // Get the first complete JSON object
            $jsonString = $matches[0][0];
            
            // Validate that it's proper JSON
            $decoded = json_decode($jsonString, true);
            if (json_last_error() === JSON_ERROR_NONE) {
                Log::info('Extracted JSON:', ['json' => $jsonString]);
                return $jsonString;
            }
        }

        // If no valid JSON found, try to extract from lines containing JSON-like content
        $lines = explode("\n", $rawResponse);
        foreach ($lines as $line) {
            $line = trim($line);
            if (strpos($line, '{') === 0 && strpos($line, '}') !== false) {
                $decoded = json_decode($line, true);
                if (json_last_error() === JSON_ERROR_NONE) {
                    Log::info('Extracted JSON from line:', ['json' => $line]);
                    return $line;
                }
            }
        }

        // If still no valid JSON, try to parse descriptive response
        Log::warning('No valid JSON found in response, attempting to parse descriptive text');
        return $this->parseDescriptiveResponse($rawResponse);
    }

    /**
     * Parse descriptive text response and convert to JSON
     *
     * @param string $response
     * @return string
     */
    private function parseDescriptiveResponse($response)
    {
        $genericAttributes = [];
        $categorySpecificAttributes = [];
        
        // Define attribute mappings
        $attributeMap = [
            // Generic attributes
            'customer service' => 'customerService',
            'app usability' => 'appUsability',
            'pricing' => 'pricing',
            'security' => 'security',
            'user experience' => 'userExperience',
            'reliability' => 'reliability',
            'accessible' => 'accessibility',
            'credibility' => 'credibility',
            'responsive' => 'responsiveness',
            'harassment' => 'harassmentOrDiscrimination',
            'discrimination' => 'harassmentOrDiscrimination',
            'overall' => 'overallSentiment',
            
            // Category specific attributes
            '5g network' => '5G network',
            'internet speed' => 'internet/data speed',
            'data speed' => 'internet/data speed',
            'network coverage' => 'network coverage',
            'loyalty programs' => 'loyaltyPrograms',
            'bill payment' => 'bill payment options',
            'personalization' => 'Personalization'
        ];
        
        // Convert response to lowercase for easier matching
        $responseLower = strtolower($response);
        
        // Look for positive indicators
        foreach ($attributeMap as $keyword => $attribute) {
            if (strpos($responseLower, $keyword) !== false) {
                // Determine sentiment based on context
                $sentiment = 'Positive'; // Default to positive since the response seems to be listing good things
                
                // Check for negative indicators
                if (strpos($responseLower, "no $keyword") !== false || 
                    strpos($responseLower, "bad $keyword") !== false ||
                    strpos($responseLower, "poor $keyword") !== false) {
                    $sentiment = 'Negative';
                }
                
                // Special case for harassment/discrimination
                if ($keyword === 'harassment' || $keyword === 'discrimination') {
                    if (strpos($responseLower, 'no harassment') !== false || 
                        strpos($responseLower, 'no discrimination') !== false) {
                        $sentiment = 'Positive'; // No harassment is good
                    }
                }
                
                // Categorize the attribute
                if (in_array($attribute, ['customerService', 'appUsability', 'pricing', 'security', 
                                        'userExperience', 'reliability', 'accessibility', 'credibility', 
                                        'responsiveness', 'harassmentOrDiscrimination', 'overallSentiment'])) {
                    $genericAttributes[$attribute] = $sentiment;
                } else {
                    $categorySpecificAttributes[$attribute] = $sentiment;
                }
            }
        }
        
        // Ensure we have some basic attributes if none were found
        if (empty($genericAttributes) && empty($categorySpecificAttributes)) {
            $genericAttributes = [
                'overallSentiment' => 'Positive',
                'customerService' => 'Positive',
                'userExperience' => 'Positive'
            ];
        }
        
        $result = [
            'generic_attributes' => $genericAttributes,
            'category_specific_attributes' => $categorySpecificAttributes
        ];
        
        $jsonResult = json_encode($result);
        Log::info('Parsed descriptive response to JSON:', ['json' => $jsonResult]);
        
        return $jsonResult;
    }
}
